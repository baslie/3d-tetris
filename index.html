<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Tetris</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body { overflow: hidden; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }
    #preview {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 150px;
      height: 150px;
      border: 1px solid rgba(74, 158, 255, 0.3);
      border-radius: 8px;
      overflow: hidden;
    }
    #preview canvas { width: 100%; height: 100%; }
    #preview-label {
      position: absolute;
      top: 165px;
      right: 10px;
      width: 150px;
      text-align: center;
      color: rgba(74, 158, 255, 0.7);
      font-family: sans-serif;
      font-size: 12px;
    }
    #score-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      color: rgba(74, 158, 255, 0.9);
      font-family: sans-serif;
      font-size: 16px;
      line-height: 1.6;
      pointer-events: none;
      user-select: none;
    }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      font-family: sans-serif;
      color: #fff;
    }
    .overlay h1 {
      font-size: 48px;
      margin-bottom: 24px;
      letter-spacing: 4px;
      text-shadow: 0 0 20px rgba(74, 158, 255, 0.8);
    }
    .overlay p {
      color: rgba(255,255,255,0.6);
      font-size: 14px;
      margin-bottom: 8px;
    }
    .overlay-btn {
      margin-top: 24px;
      padding: 14px 48px;
      font-size: 18px;
      font-family: sans-serif;
      color: #fff;
      background: transparent;
      border: 2px solid #4a9eff;
      border-radius: 6px;
      cursor: pointer;
      letter-spacing: 2px;
      transition: background 0.2s, box-shadow 0.2s;
    }
    .overlay-btn:hover {
      background: rgba(74, 158, 255, 0.2);
      box-shadow: 0 0 16px rgba(74, 158, 255, 0.4);
    }
    #controls-help {
      position: absolute;
      bottom: 12px;
      right: 12px;
      color: rgba(255,255,255,0.35);
      font-family: monospace;
      font-size: 12px;
      line-height: 1.5;
      pointer-events: none;
      user-select: none;
      z-index: 5;
    }
    #touch-controls {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 8;
      padding: 8px;
      gap: 8px;
      justify-content: space-between;
      align-items: end;
      pointer-events: none;
    }
    @media (pointer: coarse) {
      #touch-controls { display: flex; }
      #controls-help { display: none !important; }
    }
    .touch-group {
      display: grid;
      gap: 4px;
      pointer-events: auto;
    }
    .touch-group.dpad {
      grid-template-columns: repeat(3, 48px);
      grid-template-rows: repeat(3, 48px);
    }
    .touch-group.actions {
      grid-template-columns: repeat(2, 48px);
      grid-template-rows: repeat(2, 48px);
    }
    .tbtn {
      width: 48px;
      height: 48px;
      border: 1.5px solid rgba(74,158,255,0.5);
      border-radius: 8px;
      background: rgba(74,158,255,0.12);
      color: rgba(255,255,255,0.7);
      font-size: 18px;
      font-family: sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }
    .tbtn:active {
      background: rgba(74,158,255,0.35);
    }
  </style>
</head>
<body>
  <!-- –û–≤–µ—Ä–ª–µ–∏ -->
  <div id="start-screen" class="overlay">
    <h1>3D TETRIS</h1>
    <p>–°—Ç—Ä–µ–ª–∫–∏ ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ &nbsp; Q/E ‚Äî –ø–æ–≤–æ—Ä–æ—Ç Y</p>
    <p>R/F ‚Äî –ø–æ–≤–æ—Ä–æ—Ç X &nbsp; –ü—Ä–æ–±–µ–ª ‚Äî —Å–±—Ä–æ—Å</p>
    <p>Shift ‚Äî —É—Å–∫–æ—Ä–µ–Ω–∏–µ &nbsp; Esc ‚Äî –ø–∞—É–∑–∞</p>
    <p id="start-hiscore" style="color:#4a9eff;margin-top:12px;font-size:16px"></p>
    <button class="overlay-btn" onclick="startGame()">–°–¢–ê–†–¢</button>
  </div>
  <div id="pause-screen" class="overlay" style="display:none">
    <h1>–ü–ê–£–ó–ê</h1>
    <button class="overlay-btn" onclick="resumeGame()">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
  </div>
  <div id="gameover-screen" class="overlay" style="display:none">
    <h1>GAME OVER</h1>
    <p style="font-size:22px;color:#4a9eff;margin-bottom:4px">–°—á—ë—Ç: <span id="final-score">0</span></p>
    <p id="new-record" style="color:#ff4a4a;font-size:18px;display:none">üèÜ –ù–û–í–´–ô –†–ï–ö–û–†–î!</p>
    <button class="overlay-btn" onclick="resetGame()">–ò–ì–†–ê–¢–¨ –°–ù–û–í–ê</button>
  </div>

  <div id="preview" style="display:none"><canvas id="preview-canvas"></canvas></div>
  <div id="preview-label" style="display:none">NEXT</div>
  <div id="score-panel" style="display:none">
    <div>SCORE: <span id="score-value">0</span></div>
    <div>LINES: <span id="lines-value">0</span></div>
    <div>BEST: <span id="hiscore-value">0</span></div>
  </div>
  <canvas id="c"></canvas>
  <div id="touch-controls">
    <div class="touch-group dpad">
      <div></div>
      <div class="tbtn" data-act="up">‚Üë</div>
      <div></div>
      <div class="tbtn" data-act="left">‚Üê</div>
      <div class="tbtn" data-act="drop">‚§ì</div>
      <div class="tbtn" data-act="right">‚Üí</div>
      <div></div>
      <div class="tbtn" data-act="down">‚Üì</div>
      <div></div>
    </div>
    <div class="touch-group actions">
      <div class="tbtn" data-act="rotY">Q</div>
      <div class="tbtn" data-act="rotY2">E</div>
      <div class="tbtn" data-act="rotX">R</div>
      <div class="tbtn" data-act="pause">‚è∏</div>
    </div>
  </div>
  <div id="controls-help" style="display:none">
    ‚Üê ‚Üí ‚Üë ‚Üì ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ<br>
    Q / E ‚Äî –ø–æ–≤–æ—Ä–æ—Ç Y<br>
    R / F ‚Äî –ø–æ–≤–æ—Ä–æ—Ç X<br>
    Space ‚Äî —Å–±—Ä–æ—Å –≤–Ω–∏–∑<br>
    Shift ‚Äî —É—Å–∫–æ—Ä–µ–Ω–∏–µ<br>
    Esc ‚Äî –ø–∞—É–∑–∞<br>
    H ‚Äî —Å–∫—Ä—ã—Ç—å –ø–æ–¥—Å–∫–∞–∑–∫–∏
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // --- –°—Ü–µ–Ω–∞ ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // --- –ö–∞–º–µ—Ä–∞ ---
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(8, 10, 8);

    // --- –†–µ–Ω–¥–µ—Ä–µ—Ä ---
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // --- OrbitControls ---
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(3, 6, 3);
    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controls.update();

    // --- –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞ 6√ó6 (—Å–µ—Ç–∫–∞ –ª–∏–Ω–∏–π –Ω–∞ y=0) ---
    const gridPositions = [];

    // –õ–∏–Ω–∏–∏ –≤–¥–æ–ª—å X (–ø—Ä–∏ —Ä–∞–∑–Ω—ã—Ö z)
    for (let z = 0; z <= 6; z++) {
      gridPositions.push(0, 0, z, 6, 0, z);
    }
    // –õ–∏–Ω–∏–∏ –≤–¥–æ–ª—å Z (–ø—Ä–∏ —Ä–∞–∑–Ω—ã—Ö x)
    for (let x = 0; x <= 6; x++) {
      gridPositions.push(x, 0, 0, x, 0, 6);
    }

    const gridGeometry = new THREE.BufferGeometry();
    gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPositions, 3));
    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x4a9eff, transparent: true, opacity: 0.5 });
    const grid = new THREE.LineSegments(gridGeometry, gridMaterial);
    scene.add(grid);

    // --- –ì—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—è (wireframe-–∫—É–± 6√ó6√ó12) ---
    const boxGeometry = new THREE.BoxGeometry(6, 12, 6);
    const edgesGeometry = new THREE.EdgesGeometry(boxGeometry);
    const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x4a9eff, transparent: true, opacity: 0.2 });
    const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
    edges.position.set(3, 6, 3);
    scene.add(edges);

    // --- –ü–ª–æ—Å–∫–æ—Å—Ç—å-–ø—Ä–∏—ë–º–Ω–∏–∫ —Ç–µ–Ω–µ–π ---
    const groundGeo = new THREE.PlaneGeometry(6, 6);
    const groundMat = new THREE.ShadowMaterial({ opacity: 0.3 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.set(3, 0.01, 3);
    ground.receiveShadow = true;
    scene.add(ground);

    // --- –û—Å–≤–µ—â–µ–Ω–∏–µ ---
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 15, 5);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024;
    dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.near = 0.5;
    dirLight.shadow.camera.far = 30;
    dirLight.shadow.camera.left = -8;
    dirLight.shadow.camera.right = 8;
    dirLight.shadow.camera.top = 15;
    dirLight.shadow.camera.bottom = -2;
    scene.add(dirLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // --- –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ ---
    const FIELD = { W: 6, H: 12, D: 6 };
    const fieldGrid = [];
    function initGrid() {
      for (let x = 0; x < FIELD.W; x++) {
        fieldGrid[x] = [];
        for (let y = 0; y < FIELD.H; y++) {
          fieldGrid[x][y] = [];
          for (let z = 0; z < FIELD.D; z++) {
            fieldGrid[x][y][z] = null;
          }
        }
      }
    }
    initGrid();

    // --- –§–∏–≥—É—Ä—ã ---
    const PIECES = [
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[3,0,0]], color: 0x00f0f0 }, // I
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[2,0,1]], color: 0xf0a000 }, // L
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[1,0,1]], color: 0xa000f0 }, // T
      { blocks: [[0,0,0],[1,0,0],[1,0,1],[2,0,1]], color: 0x00f000 }, // S
      { blocks: [[0,0,0],[1,0,0],[0,0,1],[1,0,1]], color: 0xf0f000 }, // O
    ];

    // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã ---
    let gameState = 'start'; // 'start' | 'playing' | 'paused' | 'gameover'
    let ghostGroup = null;
    let hiScore = parseInt(localStorage.getItem('tetris3d-hiscore')) || 0;

    // --- –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ñ–∏–≥—É—Ä—ã ---
    let currentPiece = null;
    let currentPosition = { x: 0, y: 0, z: 0 };
    let currentGroup = null;
    let nextPiece = null;

    function randomPiece() {
      return PIECES[Math.floor(Math.random() * PIECES.length)];
    }

    function createPieceMesh(piece) {
      const group = new THREE.Group();
      piece.blocks.forEach(([dx, dy, dz]) => {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshLambertMaterial({ color: piece.color });
        const cube = new THREE.Mesh(geo, mat);
        cube.castShadow = true;
        cube.position.set(dx, dy, dz);
        group.add(cube);
      });
      return group;
    }

    function getPieceBounds(piece) {
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      let minZ = Infinity, maxZ = -Infinity;
      piece.blocks.forEach(([dx, dy, dz]) => {
        minX = Math.min(minX, dx); maxX = Math.max(maxX, dx);
        minY = Math.min(minY, dy); maxY = Math.max(maxY, dy);
        minZ = Math.min(minZ, dz); maxZ = Math.max(maxZ, dz);
      });
      return { minX, maxX, minY, maxY, minZ, maxZ,
        w: maxX - minX + 1, h: maxY - minY + 1, d: maxZ - minZ + 1 };
    }

    function renderCurrentPiece() {
      if (currentGroup) scene.remove(currentGroup);
      if (!currentPiece) return;
      currentGroup = createPieceMesh(currentPiece);
      currentGroup.position.set(
        currentPosition.x + 0.5,
        currentPosition.y + 0.5,
        currentPosition.z + 0.5
      );
      scene.add(currentGroup);
      renderGhost();
    }

    // --- –ü—Ä–µ–≤—å—é —Å–ª–µ–¥—É—é—â–µ–π —Ñ–∏–≥—É—Ä—ã ---
    const previewCanvas = document.getElementById('preview-canvas');
    previewCanvas.width = 150;
    previewCanvas.height = 150;
    const previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true });
    previewRenderer.setSize(150, 150);
    previewRenderer.setClearColor(0x1a1a2e);

    const previewScene = new THREE.Scene();
    const previewCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 50);
    previewCamera.position.set(3, 3, 3);
    previewCamera.lookAt(0, 0, 0);

    const previewAmbient = new THREE.AmbientLight(0xffffff, 0.6);
    previewScene.add(previewAmbient);
    const previewDir = new THREE.DirectionalLight(0xffffff, 0.8);
    previewDir.position.set(3, 5, 3);
    previewScene.add(previewDir);

    function renderNextPreview() {
      // –û—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –º–µ—à–∏
      while (previewScene.children.length > 2) {
        previewScene.remove(previewScene.children[previewScene.children.length - 1]);
      }
      if (!nextPiece) return;
      const mesh = createPieceMesh(nextPiece);
      // –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–∏–≥—É—Ä—É –≤–æ–∫—Ä—É–≥ origin
      const bounds = getPieceBounds(nextPiece);
      mesh.position.set(
        -(bounds.minX + bounds.maxX) / 2,
        -(bounds.minY + bounds.maxY) / 2,
        -(bounds.minZ + bounds.maxZ) / 2
      );
      previewScene.add(mesh);
      previewRenderer.render(previewScene, previewCamera);
    }

    // --- –°–ø–∞–≤–Ω —Ñ–∏–≥—É—Ä—ã ---
    function spawnPiece() {
      currentPiece = nextPiece || randomPiece();
      nextPiece = randomPiece();
      // –ù–µ –¥–∞–≤–∞—Ç—å –¥–≤–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–æ–¥—Ä—è–¥
      while (nextPiece === currentPiece) {
        nextPiece = randomPiece();
      }
      const bounds = getPieceBounds(currentPiece);
      currentPosition.x = Math.floor((FIELD.W - bounds.w) / 2);
      currentPosition.z = Math.floor((FIELD.D - bounds.d) / 2);
      currentPosition.y = FIELD.H - bounds.h;
      if (!canPlace(currentPiece, currentPosition)) {
        currentPiece = null;
        gameOver();
        return;
      }
      renderCurrentPiece();
      renderNextPreview();
    }

    // --- –•—Ä–∞–Ω–∏–ª–∏—â–µ –º–µ—à–µ–π –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤ ---
    const blockMeshes = [];
    for (let x = 0; x < FIELD.W; x++) {
      blockMeshes[x] = [];
      for (let y = 0; y < FIELD.H; y++) {
        blockMeshes[x][y] = [];
        for (let z = 0; z < FIELD.D; z++) blockMeshes[x][y][z] = null;
      }
    }

    // --- –ö–æ–ª–ª–∏–∑–∏–∏ ---
    function getAbsBlocks(piece, pos) {
      return piece.blocks.map(([dx, dy, dz]) => [pos.x + dx, pos.y + dy, pos.z + dz]);
    }

    function canPlace(piece, pos) {
      return getAbsBlocks(piece, pos).every(([x, y, z]) =>
        x >= 0 && x < FIELD.W &&
        y >= 0 && y < FIELD.H &&
        z >= 0 && z < FIELD.D &&
        fieldGrid[x][y][z] === null
      );
    }

    // --- –î–≤–∏–∂–µ–Ω–∏–µ ---
    function tryMove(dx, dy, dz) {
      const np = { x: currentPosition.x + dx, y: currentPosition.y + dy, z: currentPosition.z + dz };
      if (canPlace(currentPiece, np)) {
        currentPosition = np;
        renderCurrentPiece();
        return true;
      }
      return false;
    }

    // --- –í—Ä–∞—â–µ–Ω–∏–µ ---
    function rotatePiece(axis, dir) {
      const rotated = currentPiece.blocks.map(([x, y, z]) => {
        if (axis === 'y') return dir > 0 ? [-z, y, x] : [z, y, -x];
        return dir > 0 ? [x, -z, y] : [x, z, -y];
      });
      let mnX = Infinity, mnY = Infinity, mnZ = Infinity;
      rotated.forEach(([x, y, z]) => { mnX = Math.min(mnX, x); mnY = Math.min(mnY, y); mnZ = Math.min(mnZ, z); });
      const norm = rotated.map(([x, y, z]) => [x - mnX, y - mnY, z - mnZ]);
      const test = { blocks: norm, color: currentPiece.color };
      if (canPlace(test, currentPosition)) {
        currentPiece = test;
        renderCurrentPiece();
      }
    }

    // --- –§–∏–∫—Å–∞—Ü–∏—è —Ñ–∏–≥—É—Ä—ã ---
    function lockPiece() {
      sfxLand();
      getAbsBlocks(currentPiece, currentPosition).forEach(([x, y, z]) => {
        fieldGrid[x][y][z] = currentPiece.color;
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshLambertMaterial({ color: currentPiece.color });
        const cube = new THREE.Mesh(geo, mat);
        cube.castShadow = true;
        cube.receiveShadow = true;
        cube.position.set(x + 0.5, y + 0.5, z + 0.5);
        scene.add(cube);
        blockMeshes[x][y][z] = cube;
      });
      if (currentGroup) scene.remove(currentGroup);
      currentGroup = null;
      if (ghostGroup) { scene.remove(ghostGroup); ghostGroup = null; }
      currentPiece = null;
      checkAndClearLayers();
    }

    // --- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ —Å–ª–æ—ë–≤ ---
    function checkAndClearLayers() {
      // –°–æ–±—Ä–∞—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å–ª–æ–∏
      const fullLayers = [];
      for (let y = 0; y < FIELD.H; y++) {
        let full = true;
        for (let x = 0; x < FIELD.W && full; x++) {
          for (let z = 0; z < FIELD.D && full; z++) {
            if (fieldGrid[x][y][z] === null) full = false;
          }
        }
        if (full) fullLayers.push(y);
      }

      if (fullLayers.length === 0) {
        spawnPiece();
        return;
      }

      // –ü–æ–¥—Å—á—ë—Ç –æ—á–∫–æ–≤
      const cnt = fullLayers.length;
      const pts = cnt === 1 ? 100 : cnt === 2 ? 300 : cnt === 3 ? 600 : 1000;
      score += pts;
      totalLines += cnt;
      dropInterval = 1000 * Math.pow(0.9, Math.floor(totalLines / 5));
      updateHUD();

      sfxClear();
      // –ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è
      animating = true;
      animStartTime = performance.now();
      animClearedYs = fullLayers;
      animMeshes = [];

      for (const y of fullLayers) {
        for (let x = 0; x < FIELD.W; x++) {
          for (let z = 0; z < FIELD.D; z++) {
            const mesh = blockMeshes[x][y][z];
            if (mesh) {
              mesh.material.color.set(0xffffff);
              animMeshes.push(mesh);
            }
          }
        }
      }
    }

    function finishClearAnimation() {
      // –£–¥–∞–ª–∏—Ç—å –º–µ—à–∏ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö —Å–ª–æ—ë–≤
      for (const y of animClearedYs) {
        for (let x = 0; x < FIELD.W; x++) {
          for (let z = 0; z < FIELD.D; z++) {
            const mesh = blockMeshes[x][y][z];
            if (mesh) scene.remove(mesh);
            blockMeshes[x][y][z] = null;
            fieldGrid[x][y][z] = null;
          }
        }
      }

      // –°–¥–≤–∏–≥ —Å–ª–æ—ë–≤ –≤–Ω–∏–∑ ‚Äî –æ–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª—ë–Ω–Ω—ã—Ö —Å–ª–æ—ë–≤ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
      const sorted = [...animClearedYs].sort((a, b) => a - b);
      for (const removedY of sorted) {
        for (let y = removedY; y < FIELD.H - 1; y++) {
          for (let x = 0; x < FIELD.W; x++) {
            for (let z = 0; z < FIELD.D; z++) {
              fieldGrid[x][y][z] = fieldGrid[x][y + 1][z];
              fieldGrid[x][y + 1][z] = null;
              blockMeshes[x][y][z] = blockMeshes[x][y + 1][z];
              blockMeshes[x][y + 1][z] = null;
              if (blockMeshes[x][y][z]) {
                blockMeshes[x][y][z].position.y = y + 0.5;
              }
            }
          }
        }
      }

      animMeshes = [];
      animClearedYs = [];
      animating = false;
      spawnPiece();
    }

    // --- Ghost piece ---
    function renderGhost() {
      if (ghostGroup) { scene.remove(ghostGroup); ghostGroup = null; }
      if (!currentPiece) return;
      // –ù–∞–π—Ç–∏ —Å–∞–º—É—é –Ω–∏–∑–∫—É—é –≤–∞–ª–∏–¥–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
      const ghostPos = { ...currentPosition };
      while (true) {
        const next = { x: ghostPos.x, y: ghostPos.y - 1, z: ghostPos.z };
        if (!canPlace(currentPiece, next)) break;
        ghostPos.y = next.y;
      }
      // –ù–µ —Ä–∏—Å–æ–≤–∞—Ç—å ghost –Ω–∞ —Ç–æ–π –∂–µ –ø–æ–∑–∏—Ü–∏–∏
      if (ghostPos.y === currentPosition.y) return;
      ghostGroup = new THREE.Group();
      currentPiece.blocks.forEach(([dx, dy, dz]) => {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshLambertMaterial({
          color: currentPiece.color,
          transparent: true,
          opacity: 0.2,
        });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(dx, dy, dz);
        ghostGroup.add(cube);
      });
      ghostGroup.position.set(ghostPos.x + 0.5, ghostPos.y + 0.5, ghostPos.z + 0.5);
      scene.add(ghostGroup);
    }

    // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º –∏–≥—Ä—ã ---
    // –ü–æ–∫–∞–∑–∞—Ç—å hi-score –Ω–∞ —Å—Ç–∞—Ä—Ç–æ–≤–æ–º —ç–∫—Ä–∞–Ω–µ
    (function() {
      const el = document.getElementById('start-hiscore');
      if (hiScore > 0) el.textContent = '–†–µ–∫–æ—Ä–¥: ' + hiScore;
    })();

    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('preview').style.display = '';
      document.getElementById('preview-label').style.display = '';
      document.getElementById('score-panel').style.display = '';
      document.getElementById('controls-help').style.display = 'block';
      score = 0;
      totalLines = 0;
      dropInterval = 1000;
      updateHUD();
      gameState = 'playing';
      lastDropTime = performance.now();
      spawnPiece();
    }

    function pauseGame() {
      document.getElementById('pause-screen').style.display = '';
      gameState = 'paused';
    }

    function resumeGame() {
      document.getElementById('pause-screen').style.display = 'none';
      gameState = 'playing';
      lastDropTime = performance.now();
    }

    function gameOver() {
      sfxGameOver();
      if (ghostGroup) { scene.remove(ghostGroup); ghostGroup = null; }
      if (currentGroup) { scene.remove(currentGroup); currentGroup = null; }
      document.getElementById('final-score').textContent = score;
      const isRecord = score > hiScore;
      if (isRecord) {
        hiScore = score;
        localStorage.setItem('tetris3d-hiscore', hiScore);
      }
      document.getElementById('new-record').style.display = isRecord ? '' : 'none';
      document.getElementById('gameover-screen').style.display = '';
      gameState = 'gameover';
    }

    function resetGame() {
      document.getElementById('gameover-screen').style.display = 'none';
      // –û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ
      for (let x = 0; x < FIELD.W; x++) {
        for (let y = 0; y < FIELD.H; y++) {
          for (let z = 0; z < FIELD.D; z++) {
            fieldGrid[x][y][z] = null;
            if (blockMeshes[x][y][z]) {
              scene.remove(blockMeshes[x][y][z]);
              blockMeshes[x][y][z] = null;
            }
          }
        }
      }
      currentPiece = null;
      nextPiece = null;
      startGame();
    }

    // --- –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª ---
    let dropInterval = 1000;
    let lastDropTime = performance.now();
    let softDrop = false;
    let score = 0;
    let totalLines = 0;
    let animating = false;
    let animStartTime = 0;
    let animMeshes = [];
    let animClearedYs = [];
    let smoothDrop = { active: false, fromY: 0, toY: 0, start: 0 };
    const SMOOTH_DROP_MS = 100;
    let hardDropTrail = { active: false, meshes: [], start: 0 };
    const TRAIL_MS = 300;

    // --- –ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã (Web Audio API) ---
    let audioCtx = null;
    function ensureAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
      return audioCtx;
    }
    function playTone(freq, duration, type, freqEnd) {
      const ctx = ensureAudio();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = type || 'square';
      osc.frequency.setValueAtTime(freq, ctx.currentTime);
      if (freqEnd) osc.frequency.linearRampToValueAtTime(freqEnd, ctx.currentTime + duration);
      gain.gain.setValueAtTime(0.15, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
      osc.connect(gain).connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + duration);
    }
    function sfxMove() { playTone(600, 0.04, 'square'); }
    function sfxRotate() { playTone(800, 0.05, 'square'); }
    function sfxLand() { playTone(150, 0.1, 'triangle'); }
    function sfxHardDrop() { playTone(200, 0.15, 'sawtooth', 80); }
    function sfxClear() { playTone(400, 0.25, 'sine', 1000); }
    function sfxGameOver() { playTone(400, 0.6, 'sawtooth', 80); }

    // --- –≠—Ñ—Ñ–µ–∫—Ç hard drop ---
    function spawnHardDropTrail(piece, fromY, toY, posX, posZ) {
      hardDropTrail.meshes.forEach(m => scene.remove(m));
      hardDropTrail.meshes = [];
      const height = fromY - toY;
      if (height <= 1) return;
      piece.blocks.forEach(([dx, dy, dz]) => {
        const geo = new THREE.BoxGeometry(0.3, height, 0.3);
        const mat = new THREE.MeshBasicMaterial({ color: piece.color, transparent: true, opacity: 0.5 });
        const trail = new THREE.Mesh(geo, mat);
        trail.position.set(posX + dx + 0.5, toY + dy + 0.5 + height / 2, posZ + dz + 0.5);
        scene.add(trail);
        hardDropTrail.meshes.push(trail);
      });
      hardDropTrail.active = true;
      hardDropTrail.start = performance.now();
    }

    function updateHUD() {
      document.getElementById('score-value').textContent = score;
      document.getElementById('lines-value').textContent = totalLines;
      document.getElementById('hiscore-value').textContent = hiScore;
    }

    function gameTick(now) {
      if (gameState !== 'playing' || animating || !currentPiece) return;
      const interval = softDrop ? dropInterval / 4 : dropInterval;
      if (now - lastDropTime >= interval) {
        const np = { x: currentPosition.x, y: currentPosition.y - 1, z: currentPosition.z };
        if (canPlace(currentPiece, np)) {
          const oldY = currentPosition.y;
          currentPosition = np;
          smoothDrop = { active: true, fromY: oldY + 0.5, toY: np.y + 0.5, start: now };
          if (currentGroup) {
            currentGroup.position.set(currentPosition.x + 0.5, oldY + 0.5, currentPosition.z + 0.5);
          }
          renderGhost();
        } else {
          lockPiece();
        }
        lastDropTime = now;
      }
    }

    // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π ---
    window.addEventListener('keydown', (e) => {
      // Toggle –ø–æ–¥—Å–∫–∞–∑–æ–∫
      if (e.code === 'KeyH') {
        const help = document.getElementById('controls-help');
        help.style.display = help.style.display === 'none' ? 'block' : 'none';
        return;
      }
      // –ü–∞—É–∑–∞
      if (e.code === 'Escape') {
        if (gameState === 'playing') pauseGame();
        else if (gameState === 'paused') resumeGame();
        return;
      }
      // –ò–≥—Ä–æ–≤—ã–µ –∫–ª–∞–≤–∏—à–∏ —Ç–æ–ª—å–∫–æ –≤ playing
      if (gameState !== 'playing' || animating || !currentPiece) return;
      switch (e.code) {
        case 'ArrowLeft':  if (tryMove(-1, 0, 0)) sfxMove(); break;
        case 'ArrowRight': if (tryMove(1, 0, 0)) sfxMove(); break;
        case 'ArrowUp':    if (tryMove(0, 0, -1)) sfxMove(); break;
        case 'ArrowDown':  if (tryMove(0, 0, 1)) sfxMove(); break;
        case 'KeyQ': rotatePiece('y', 1); sfxRotate(); break;
        case 'KeyE': rotatePiece('y', -1); sfxRotate(); break;
        case 'KeyR': rotatePiece('x', 1); sfxRotate(); break;
        case 'KeyF': rotatePiece('x', -1); sfxRotate(); break;
        case 'Space': {
          const startY = currentPosition.y;
          while (tryMove(0, -1, 0)) {}
          spawnHardDropTrail(currentPiece, startY, currentPosition.y, currentPosition.x, currentPosition.z);
          sfxHardDrop();
          lockPiece();
          break;
        }
        case 'ShiftLeft':
        case 'ShiftRight':
          softDrop = true;
          break;
      }
      if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space'].includes(e.code)) e.preventDefault();
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') softDrop = false;
    });

    // --- Touch-–∫–æ–Ω—Ç—Ä–æ–ª—ã ---
    document.getElementById('touch-controls').addEventListener('pointerdown', (e) => {
      const act = e.target.dataset.act;
      if (!act) return;
      e.preventDefault();
      if (act === 'pause') {
        if (gameState === 'playing') pauseGame();
        else if (gameState === 'paused') resumeGame();
        return;
      }
      if (gameState !== 'playing' || animating || !currentPiece) return;
      switch (act) {
        case 'left':  if (tryMove(-1, 0, 0)) sfxMove(); break;
        case 'right': if (tryMove(1, 0, 0)) sfxMove(); break;
        case 'up':    if (tryMove(0, 0, -1)) sfxMove(); break;
        case 'down':  if (tryMove(0, 0, 1)) sfxMove(); break;
        case 'rotY':  rotatePiece('y', 1); sfxRotate(); break;
        case 'rotY2': rotatePiece('y', -1); sfxRotate(); break;
        case 'rotX':  rotatePiece('x', 1); sfxRotate(); break;
        case 'drop': {
          const startY = currentPosition.y;
          while (tryMove(0, -1, 0)) {}
          spawnHardDropTrail(currentPiece, startY, currentPosition.y, currentPosition.x, currentPosition.z);
          sfxHardDrop();
          lockPiece();
          break;
        }
      }
    });

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Animation loop ---
    function animate(time) {
      const now = time || performance.now();

      // –ê–Ω–∏–º–∞—Ü–∏—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è —Å–ª–æ—ë–≤
      if (animating) {
        const elapsed = now - animStartTime;
        const t = Math.min(elapsed / 300, 1);
        const s = 1 - t;
        for (const mesh of animMeshes) {
          mesh.scale.set(s, s, s);
        }
        if (t >= 1) {
          finishClearAnimation();
        }
      }

      // –ê–Ω–∏–º–∞—Ü–∏—è trail –æ—Ç hard drop
      if (hardDropTrail.active) {
        const t = Math.min((now - hardDropTrail.start) / TRAIL_MS, 1);
        for (const m of hardDropTrail.meshes) {
          m.material.opacity = 0.5 * (1 - t);
          m.scale.x = 1 - t * 0.5;
          m.scale.z = 1 - t * 0.5;
        }
        if (t >= 1) {
          hardDropTrail.meshes.forEach(m => scene.remove(m));
          hardDropTrail.meshes = [];
          hardDropTrail.active = false;
        }
      }

      // –ü–ª–∞–≤–Ω–æ–µ –ø–∞–¥–µ–Ω–∏–µ
      if (smoothDrop.active && currentGroup) {
        const t = Math.min((now - smoothDrop.start) / SMOOTH_DROP_MS, 1);
        currentGroup.position.y = smoothDrop.fromY + (smoothDrop.toY - smoothDrop.fromY) * t;
        if (t >= 1) smoothDrop.active = false;
      }

      gameTick(now);
      controls.update();
      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(animate);
  </script>
</body>
</html>
