<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Tetris</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body { overflow: hidden; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }
    #preview {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 150px;
      height: 150px;
      border: 1px solid rgba(74, 158, 255, 0.3);
      border-radius: 8px;
      overflow: hidden;
    }
    #preview canvas { width: 100%; height: 100%; }
    #preview-label {
      position: absolute;
      top: 165px;
      right: 10px;
      width: 150px;
      text-align: center;
      color: rgba(74, 158, 255, 0.7);
      font-family: sans-serif;
      font-size: 12px;
    }
    #score-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      color: rgba(74, 158, 255, 0.9);
      font-family: sans-serif;
      font-size: 16px;
      line-height: 1.6;
      pointer-events: none;
      user-select: none;
    }
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      font-family: sans-serif;
      color: #fff;
    }
    .overlay h1 {
      font-size: 48px;
      margin-bottom: 24px;
      letter-spacing: 4px;
      text-shadow: 0 0 20px rgba(74, 158, 255, 0.8);
    }
    .overlay p {
      color: rgba(255,255,255,0.6);
      font-size: 14px;
      margin-bottom: 8px;
    }
    .overlay-btn {
      margin-top: 24px;
      padding: 14px 48px;
      font-size: 18px;
      font-family: sans-serif;
      color: #fff;
      background: transparent;
      border: 2px solid #4a9eff;
      border-radius: 6px;
      cursor: pointer;
      letter-spacing: 2px;
      transition: background 0.2s, box-shadow 0.2s;
    }
    .overlay-btn:hover {
      background: rgba(74, 158, 255, 0.2);
      box-shadow: 0 0 16px rgba(74, 158, 255, 0.4);
    }
    #controls-help {
      position: absolute;
      bottom: 12px;
      right: 12px;
      color: rgba(255,255,255,0.35);
      font-family: monospace;
      font-size: 12px;
      line-height: 1.5;
      pointer-events: none;
      user-select: none;
      z-index: 5;
    }
  </style>
</head>
<body>
  <!-- Оверлеи -->
  <div id="start-screen" class="overlay">
    <h1>3D TETRIS</h1>
    <p>Стрелки — движение &nbsp; Q/E — поворот Y</p>
    <p>R/F — поворот X &nbsp; Пробел — сброс</p>
    <p>Shift — ускорение &nbsp; Esc — пауза</p>
    <button class="overlay-btn" onclick="startGame()">СТАРТ</button>
  </div>
  <div id="pause-screen" class="overlay" style="display:none">
    <h1>ПАУЗА</h1>
    <button class="overlay-btn" onclick="resumeGame()">ПРОДОЛЖИТЬ</button>
  </div>
  <div id="gameover-screen" class="overlay" style="display:none">
    <h1>GAME OVER</h1>
    <p style="font-size:22px;color:#4a9eff;margin-bottom:4px">Счёт: <span id="final-score">0</span></p>
    <button class="overlay-btn" onclick="resetGame()">ИГРАТЬ СНОВА</button>
  </div>

  <div id="preview" style="display:none"><canvas id="preview-canvas"></canvas></div>
  <div id="preview-label" style="display:none">NEXT</div>
  <div id="score-panel" style="display:none">
    <div>SCORE: <span id="score-value">0</span></div>
    <div>LINES: <span id="lines-value">0</span></div>
  </div>
  <canvas id="c"></canvas>
  <div id="controls-help" style="display:none">
    ← → ↑ ↓ — движение<br>
    Q / E — поворот Y<br>
    R / F — поворот X<br>
    Space — сброс вниз<br>
    Shift — ускорение<br>
    Esc — пауза<br>
    H — скрыть подсказки
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // --- Сцена ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // --- Камера ---
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(8, 10, 8);

    // --- Рендерер ---
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // --- OrbitControls ---
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(3, 6, 3);
    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controls.update();

    // --- Платформа 6×6 (сетка линий на y=0) ---
    const gridPositions = [];

    // Линии вдоль X (при разных z)
    for (let z = 0; z <= 6; z++) {
      gridPositions.push(0, 0, z, 6, 0, z);
    }
    // Линии вдоль Z (при разных x)
    for (let x = 0; x <= 6; x++) {
      gridPositions.push(x, 0, 0, x, 0, 6);
    }

    const gridGeometry = new THREE.BufferGeometry();
    gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPositions, 3));
    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x4a9eff, transparent: true, opacity: 0.5 });
    const grid = new THREE.LineSegments(gridGeometry, gridMaterial);
    scene.add(grid);

    // --- Границы поля (wireframe-куб 6×6×12) ---
    const boxGeometry = new THREE.BoxGeometry(6, 12, 6);
    const edgesGeometry = new THREE.EdgesGeometry(boxGeometry);
    const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x4a9eff, transparent: true, opacity: 0.2 });
    const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
    edges.position.set(3, 6, 3);
    scene.add(edges);

    // --- Освещение ---
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 15, 5);
    scene.add(dirLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // --- Игровое поле ---
    const FIELD = { W: 6, H: 12, D: 6 };
    const fieldGrid = [];
    function initGrid() {
      for (let x = 0; x < FIELD.W; x++) {
        fieldGrid[x] = [];
        for (let y = 0; y < FIELD.H; y++) {
          fieldGrid[x][y] = [];
          for (let z = 0; z < FIELD.D; z++) {
            fieldGrid[x][y][z] = null;
          }
        }
      }
    }
    initGrid();

    // --- Фигуры ---
    const PIECES = [
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[3,0,0]], color: 0x00f0f0 }, // I
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[2,0,1]], color: 0xf0a000 }, // L
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[1,0,1]], color: 0xa000f0 }, // T
      { blocks: [[0,0,0],[1,0,0],[1,0,1],[2,0,1]], color: 0x00f000 }, // S
      { blocks: [[0,0,0],[1,0,0],[0,0,1],[1,0,1]], color: 0xf0f000 }, // O
    ];

    // --- Состояние игры ---
    let gameState = 'start'; // 'start' | 'playing' | 'paused' | 'gameover'
    let ghostGroup = null;

    // --- Состояние текущей фигуры ---
    let currentPiece = null;
    let currentPosition = { x: 0, y: 0, z: 0 };
    let currentGroup = null;
    let nextPiece = null;

    function randomPiece() {
      return PIECES[Math.floor(Math.random() * PIECES.length)];
    }

    function createPieceMesh(piece) {
      const group = new THREE.Group();
      piece.blocks.forEach(([dx, dy, dz]) => {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshLambertMaterial({ color: piece.color });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(dx, dy, dz);
        group.add(cube);
      });
      return group;
    }

    function getPieceBounds(piece) {
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      let minZ = Infinity, maxZ = -Infinity;
      piece.blocks.forEach(([dx, dy, dz]) => {
        minX = Math.min(minX, dx); maxX = Math.max(maxX, dx);
        minY = Math.min(minY, dy); maxY = Math.max(maxY, dy);
        minZ = Math.min(minZ, dz); maxZ = Math.max(maxZ, dz);
      });
      return { minX, maxX, minY, maxY, minZ, maxZ,
        w: maxX - minX + 1, h: maxY - minY + 1, d: maxZ - minZ + 1 };
    }

    function renderCurrentPiece() {
      if (currentGroup) scene.remove(currentGroup);
      if (!currentPiece) return;
      currentGroup = createPieceMesh(currentPiece);
      currentGroup.position.set(
        currentPosition.x + 0.5,
        currentPosition.y + 0.5,
        currentPosition.z + 0.5
      );
      scene.add(currentGroup);
      renderGhost();
    }

    // --- Превью следующей фигуры ---
    const previewCanvas = document.getElementById('preview-canvas');
    previewCanvas.width = 150;
    previewCanvas.height = 150;
    const previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true });
    previewRenderer.setSize(150, 150);
    previewRenderer.setClearColor(0x1a1a2e);

    const previewScene = new THREE.Scene();
    const previewCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 50);
    previewCamera.position.set(3, 3, 3);
    previewCamera.lookAt(0, 0, 0);

    const previewAmbient = new THREE.AmbientLight(0xffffff, 0.6);
    previewScene.add(previewAmbient);
    const previewDir = new THREE.DirectionalLight(0xffffff, 0.8);
    previewDir.position.set(3, 5, 3);
    previewScene.add(previewDir);

    function renderNextPreview() {
      // Очистить старые меши
      while (previewScene.children.length > 2) {
        previewScene.remove(previewScene.children[previewScene.children.length - 1]);
      }
      if (!nextPiece) return;
      const mesh = createPieceMesh(nextPiece);
      // Центрировать фигуру вокруг origin
      const bounds = getPieceBounds(nextPiece);
      mesh.position.set(
        -(bounds.minX + bounds.maxX) / 2,
        -(bounds.minY + bounds.maxY) / 2,
        -(bounds.minZ + bounds.maxZ) / 2
      );
      previewScene.add(mesh);
      previewRenderer.render(previewScene, previewCamera);
    }

    // --- Спавн фигуры ---
    function spawnPiece() {
      currentPiece = nextPiece || randomPiece();
      nextPiece = randomPiece();
      // Не давать две одинаковые подряд
      while (nextPiece === currentPiece) {
        nextPiece = randomPiece();
      }
      const bounds = getPieceBounds(currentPiece);
      currentPosition.x = Math.floor((FIELD.W - bounds.w) / 2);
      currentPosition.z = Math.floor((FIELD.D - bounds.d) / 2);
      currentPosition.y = FIELD.H - bounds.h;
      if (!canPlace(currentPiece, currentPosition)) {
        currentPiece = null;
        gameOver();
        return;
      }
      renderCurrentPiece();
      renderNextPreview();
    }

    // --- Хранилище мешей зафиксированных блоков ---
    const blockMeshes = [];
    for (let x = 0; x < FIELD.W; x++) {
      blockMeshes[x] = [];
      for (let y = 0; y < FIELD.H; y++) {
        blockMeshes[x][y] = [];
        for (let z = 0; z < FIELD.D; z++) blockMeshes[x][y][z] = null;
      }
    }

    // --- Коллизии ---
    function getAbsBlocks(piece, pos) {
      return piece.blocks.map(([dx, dy, dz]) => [pos.x + dx, pos.y + dy, pos.z + dz]);
    }

    function canPlace(piece, pos) {
      return getAbsBlocks(piece, pos).every(([x, y, z]) =>
        x >= 0 && x < FIELD.W &&
        y >= 0 && y < FIELD.H &&
        z >= 0 && z < FIELD.D &&
        fieldGrid[x][y][z] === null
      );
    }

    // --- Движение ---
    function tryMove(dx, dy, dz) {
      const np = { x: currentPosition.x + dx, y: currentPosition.y + dy, z: currentPosition.z + dz };
      if (canPlace(currentPiece, np)) {
        currentPosition = np;
        renderCurrentPiece();
        return true;
      }
      return false;
    }

    // --- Вращение ---
    function rotatePiece(axis, dir) {
      const rotated = currentPiece.blocks.map(([x, y, z]) => {
        if (axis === 'y') return dir > 0 ? [-z, y, x] : [z, y, -x];
        return dir > 0 ? [x, -z, y] : [x, z, -y];
      });
      let mnX = Infinity, mnY = Infinity, mnZ = Infinity;
      rotated.forEach(([x, y, z]) => { mnX = Math.min(mnX, x); mnY = Math.min(mnY, y); mnZ = Math.min(mnZ, z); });
      const norm = rotated.map(([x, y, z]) => [x - mnX, y - mnY, z - mnZ]);
      const test = { blocks: norm, color: currentPiece.color };
      if (canPlace(test, currentPosition)) {
        currentPiece = test;
        renderCurrentPiece();
      }
    }

    // --- Фиксация фигуры ---
    function lockPiece() {
      getAbsBlocks(currentPiece, currentPosition).forEach(([x, y, z]) => {
        fieldGrid[x][y][z] = currentPiece.color;
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshLambertMaterial({ color: currentPiece.color });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(x + 0.5, y + 0.5, z + 0.5);
        scene.add(cube);
        blockMeshes[x][y][z] = cube;
      });
      if (currentGroup) scene.remove(currentGroup);
      currentGroup = null;
      if (ghostGroup) { scene.remove(ghostGroup); ghostGroup = null; }
      currentPiece = null;
      checkAndClearLayers();
    }

    // --- Проверка и уничтожение слоёв ---
    function checkAndClearLayers() {
      // Собрать заполненные слои
      const fullLayers = [];
      for (let y = 0; y < FIELD.H; y++) {
        let full = true;
        for (let x = 0; x < FIELD.W && full; x++) {
          for (let z = 0; z < FIELD.D && full; z++) {
            if (fieldGrid[x][y][z] === null) full = false;
          }
        }
        if (full) fullLayers.push(y);
      }

      if (fullLayers.length === 0) {
        spawnPiece();
        return;
      }

      // Подсчёт очков
      const cnt = fullLayers.length;
      const pts = cnt === 1 ? 100 : cnt === 2 ? 300 : cnt === 3 ? 600 : 1000;
      score += pts;
      totalLines += cnt;
      dropInterval = 1000 * Math.pow(0.9, Math.floor(totalLines / 5));
      updateHUD();

      // Запуск анимации уничтожения
      animating = true;
      animStartTime = performance.now();
      animClearedYs = fullLayers;
      animMeshes = [];

      for (const y of fullLayers) {
        for (let x = 0; x < FIELD.W; x++) {
          for (let z = 0; z < FIELD.D; z++) {
            const mesh = blockMeshes[x][y][z];
            if (mesh) {
              mesh.material.color.set(0xffffff);
              animMeshes.push(mesh);
            }
          }
        }
      }
    }

    function finishClearAnimation() {
      // Удалить меши удалённых слоёв
      for (const y of animClearedYs) {
        for (let x = 0; x < FIELD.W; x++) {
          for (let z = 0; z < FIELD.D; z++) {
            const mesh = blockMeshes[x][y][z];
            if (mesh) scene.remove(mesh);
            blockMeshes[x][y][z] = null;
            fieldGrid[x][y][z] = null;
          }
        }
      }

      // Сдвиг слоёв вниз — обработка удалённых слоёв снизу вверх
      const sorted = [...animClearedYs].sort((a, b) => a - b);
      for (const removedY of sorted) {
        for (let y = removedY; y < FIELD.H - 1; y++) {
          for (let x = 0; x < FIELD.W; x++) {
            for (let z = 0; z < FIELD.D; z++) {
              fieldGrid[x][y][z] = fieldGrid[x][y + 1][z];
              fieldGrid[x][y + 1][z] = null;
              blockMeshes[x][y][z] = blockMeshes[x][y + 1][z];
              blockMeshes[x][y + 1][z] = null;
              if (blockMeshes[x][y][z]) {
                blockMeshes[x][y][z].position.y = y + 0.5;
              }
            }
          }
        }
      }

      animMeshes = [];
      animClearedYs = [];
      animating = false;
      spawnPiece();
    }

    // --- Ghost piece ---
    function renderGhost() {
      if (ghostGroup) { scene.remove(ghostGroup); ghostGroup = null; }
      if (!currentPiece) return;
      // Найти самую низкую валидную позицию
      const ghostPos = { ...currentPosition };
      while (true) {
        const next = { x: ghostPos.x, y: ghostPos.y - 1, z: ghostPos.z };
        if (!canPlace(currentPiece, next)) break;
        ghostPos.y = next.y;
      }
      // Не рисовать ghost на той же позиции
      if (ghostPos.y === currentPosition.y) return;
      ghostGroup = new THREE.Group();
      currentPiece.blocks.forEach(([dx, dy, dz]) => {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshLambertMaterial({
          color: currentPiece.color,
          transparent: true,
          opacity: 0.2,
        });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(dx, dy, dz);
        ghostGroup.add(cube);
      });
      ghostGroup.position.set(ghostPos.x + 0.5, ghostPos.y + 0.5, ghostPos.z + 0.5);
      scene.add(ghostGroup);
    }

    // --- Управление состоянием игры ---
    function startGame() {
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('preview').style.display = '';
      document.getElementById('preview-label').style.display = '';
      document.getElementById('score-panel').style.display = '';
      document.getElementById('controls-help').style.display = 'block';
      score = 0;
      totalLines = 0;
      dropInterval = 1000;
      updateHUD();
      gameState = 'playing';
      lastDropTime = performance.now();
      spawnPiece();
    }

    function pauseGame() {
      document.getElementById('pause-screen').style.display = '';
      gameState = 'paused';
    }

    function resumeGame() {
      document.getElementById('pause-screen').style.display = 'none';
      gameState = 'playing';
      lastDropTime = performance.now();
    }

    function gameOver() {
      if (ghostGroup) { scene.remove(ghostGroup); ghostGroup = null; }
      if (currentGroup) { scene.remove(currentGroup); currentGroup = null; }
      document.getElementById('final-score').textContent = score;
      document.getElementById('gameover-screen').style.display = '';
      gameState = 'gameover';
    }

    function resetGame() {
      document.getElementById('gameover-screen').style.display = 'none';
      // Очистить поле
      for (let x = 0; x < FIELD.W; x++) {
        for (let y = 0; y < FIELD.H; y++) {
          for (let z = 0; z < FIELD.D; z++) {
            fieldGrid[x][y][z] = null;
            if (blockMeshes[x][y][z]) {
              scene.remove(blockMeshes[x][y][z]);
              blockMeshes[x][y][z] = null;
            }
          }
        }
      }
      currentPiece = null;
      nextPiece = null;
      startGame();
    }

    // --- Игровой цикл ---
    let dropInterval = 1000;
    let lastDropTime = performance.now();
    let softDrop = false;
    let score = 0;
    let totalLines = 0;
    let animating = false;
    let animStartTime = 0;
    let animMeshes = [];
    let animClearedYs = [];

    function updateHUD() {
      document.getElementById('score-value').textContent = score;
      document.getElementById('lines-value').textContent = totalLines;
    }

    function gameTick(now) {
      if (gameState !== 'playing' || animating || !currentPiece) return;
      const interval = softDrop ? dropInterval / 4 : dropInterval;
      if (now - lastDropTime >= interval) {
        if (!tryMove(0, -1, 0)) lockPiece();
        lastDropTime = now;
      }
    }

    // --- Управление клавиатурой ---
    window.addEventListener('keydown', (e) => {
      // Toggle подсказок
      if (e.code === 'KeyH') {
        const help = document.getElementById('controls-help');
        help.style.display = help.style.display === 'none' ? 'block' : 'none';
        return;
      }
      // Пауза
      if (e.code === 'Escape') {
        if (gameState === 'playing') pauseGame();
        else if (gameState === 'paused') resumeGame();
        return;
      }
      // Игровые клавиши только в playing
      if (gameState !== 'playing' || animating || !currentPiece) return;
      switch (e.code) {
        case 'ArrowLeft':  tryMove(-1, 0, 0); break;
        case 'ArrowRight': tryMove(1, 0, 0); break;
        case 'ArrowUp':    tryMove(0, 0, -1); break;
        case 'ArrowDown':  tryMove(0, 0, 1); break;
        case 'KeyQ': rotatePiece('y', 1); break;
        case 'KeyE': rotatePiece('y', -1); break;
        case 'KeyR': rotatePiece('x', 1); break;
        case 'KeyF': rotatePiece('x', -1); break;
        case 'Space':
          while (tryMove(0, -1, 0)) {}
          lockPiece();
          break;
        case 'ShiftLeft':
        case 'ShiftRight':
          softDrop = true;
          break;
      }
      if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space'].includes(e.code)) e.preventDefault();
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') softDrop = false;
    });

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Animation loop ---
    function animate(time) {
      const now = time || performance.now();

      // Анимация уничтожения слоёв
      if (animating) {
        const elapsed = now - animStartTime;
        const t = Math.min(elapsed / 300, 1);
        const s = 1 - t;
        for (const mesh of animMeshes) {
          mesh.scale.set(s, s, s);
        }
        if (t >= 1) {
          finishClearAnimation();
        }
      }

      gameTick(now);
      controls.update();
      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(animate);
  </script>
</body>
</html>
