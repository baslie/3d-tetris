<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Tetris</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body { overflow: hidden; width: 100%; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }
    #preview {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 150px;
      height: 150px;
      border: 1px solid rgba(74, 158, 255, 0.3);
      border-radius: 8px;
      overflow: hidden;
    }
    #preview canvas { width: 100%; height: 100%; }
    #preview-label {
      position: absolute;
      top: 165px;
      right: 10px;
      width: 150px;
      text-align: center;
      color: rgba(74, 158, 255, 0.7);
      font-family: sans-serif;
      font-size: 12px;
    }
    #score-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      color: rgba(74, 158, 255, 0.9);
      font-family: sans-serif;
      font-size: 16px;
      line-height: 1.6;
      pointer-events: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="preview"><canvas id="preview-canvas"></canvas></div>
  <div id="preview-label">NEXT</div>
  <div id="score-panel">
    <div>SCORE: <span id="score-value">0</span></div>
    <div>LINES: <span id="lines-value">0</span></div>
  </div>
  <canvas id="c"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // --- Сцена ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // --- Камера ---
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(8, 10, 8);

    // --- Рендерер ---
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // --- OrbitControls ---
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(3, 6, 3);
    controls.minPolarAngle = 0.1;
    controls.maxPolarAngle = Math.PI / 2 - 0.05;
    controls.update();

    // --- Платформа 6×6 (сетка линий на y=0) ---
    const gridPositions = [];

    // Линии вдоль X (при разных z)
    for (let z = 0; z <= 6; z++) {
      gridPositions.push(0, 0, z, 6, 0, z);
    }
    // Линии вдоль Z (при разных x)
    for (let x = 0; x <= 6; x++) {
      gridPositions.push(x, 0, 0, x, 0, 6);
    }

    const gridGeometry = new THREE.BufferGeometry();
    gridGeometry.setAttribute('position', new THREE.Float32BufferAttribute(gridPositions, 3));
    const gridMaterial = new THREE.LineBasicMaterial({ color: 0x4a9eff, transparent: true, opacity: 0.5 });
    const grid = new THREE.LineSegments(gridGeometry, gridMaterial);
    scene.add(grid);

    // --- Границы поля (wireframe-куб 6×6×12) ---
    const boxGeometry = new THREE.BoxGeometry(6, 12, 6);
    const edgesGeometry = new THREE.EdgesGeometry(boxGeometry);
    const edgesMaterial = new THREE.LineBasicMaterial({ color: 0x4a9eff, transparent: true, opacity: 0.2 });
    const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
    edges.position.set(3, 6, 3);
    scene.add(edges);

    // --- Освещение ---
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 15, 5);
    scene.add(dirLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // --- Игровое поле ---
    const FIELD = { W: 6, H: 12, D: 6 };
    const fieldGrid = [];
    function initGrid() {
      for (let x = 0; x < FIELD.W; x++) {
        fieldGrid[x] = [];
        for (let y = 0; y < FIELD.H; y++) {
          fieldGrid[x][y] = [];
          for (let z = 0; z < FIELD.D; z++) {
            fieldGrid[x][y][z] = null;
          }
        }
      }
    }
    initGrid();

    // --- Фигуры ---
    const PIECES = [
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[3,0,0]], color: 0x00f0f0 }, // I
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[2,0,1]], color: 0xf0a000 }, // L
      { blocks: [[0,0,0],[1,0,0],[2,0,0],[1,0,1]], color: 0xa000f0 }, // T
      { blocks: [[0,0,0],[1,0,0],[1,0,1],[2,0,1]], color: 0x00f000 }, // S
      { blocks: [[0,0,0],[1,0,0],[0,0,1],[1,0,1]], color: 0xf0f000 }, // O
    ];

    // --- Состояние текущей фигуры ---
    let currentPiece = null;
    let currentPosition = { x: 0, y: 0, z: 0 };
    let currentGroup = null;
    let nextPiece = null;

    function randomPiece() {
      return PIECES[Math.floor(Math.random() * PIECES.length)];
    }

    function createPieceMesh(piece) {
      const group = new THREE.Group();
      piece.blocks.forEach(([dx, dy, dz]) => {
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshLambertMaterial({ color: piece.color });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(dx, dy, dz);
        group.add(cube);
      });
      return group;
    }

    function getPieceBounds(piece) {
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      let minZ = Infinity, maxZ = -Infinity;
      piece.blocks.forEach(([dx, dy, dz]) => {
        minX = Math.min(minX, dx); maxX = Math.max(maxX, dx);
        minY = Math.min(minY, dy); maxY = Math.max(maxY, dy);
        minZ = Math.min(minZ, dz); maxZ = Math.max(maxZ, dz);
      });
      return { minX, maxX, minY, maxY, minZ, maxZ,
        w: maxX - minX + 1, h: maxY - minY + 1, d: maxZ - minZ + 1 };
    }

    function renderCurrentPiece() {
      if (currentGroup) scene.remove(currentGroup);
      if (!currentPiece) return;
      currentGroup = createPieceMesh(currentPiece);
      currentGroup.position.set(
        currentPosition.x + 0.5,
        currentPosition.y + 0.5,
        currentPosition.z + 0.5
      );
      scene.add(currentGroup);
    }

    // --- Превью следующей фигуры ---
    const previewCanvas = document.getElementById('preview-canvas');
    previewCanvas.width = 150;
    previewCanvas.height = 150;
    const previewRenderer = new THREE.WebGLRenderer({ canvas: previewCanvas, antialias: true });
    previewRenderer.setSize(150, 150);
    previewRenderer.setClearColor(0x1a1a2e);

    const previewScene = new THREE.Scene();
    const previewCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 50);
    previewCamera.position.set(3, 3, 3);
    previewCamera.lookAt(0, 0, 0);

    const previewAmbient = new THREE.AmbientLight(0xffffff, 0.6);
    previewScene.add(previewAmbient);
    const previewDir = new THREE.DirectionalLight(0xffffff, 0.8);
    previewDir.position.set(3, 5, 3);
    previewScene.add(previewDir);

    function renderNextPreview() {
      // Очистить старые меши
      while (previewScene.children.length > 2) {
        previewScene.remove(previewScene.children[previewScene.children.length - 1]);
      }
      if (!nextPiece) return;
      const mesh = createPieceMesh(nextPiece);
      // Центрировать фигуру вокруг origin
      const bounds = getPieceBounds(nextPiece);
      mesh.position.set(
        -(bounds.minX + bounds.maxX) / 2,
        -(bounds.minY + bounds.maxY) / 2,
        -(bounds.minZ + bounds.maxZ) / 2
      );
      previewScene.add(mesh);
      previewRenderer.render(previewScene, previewCamera);
    }

    // --- Спавн фигуры ---
    function spawnPiece() {
      currentPiece = nextPiece || randomPiece();
      nextPiece = randomPiece();
      // Не давать две одинаковые подряд
      while (nextPiece === currentPiece) {
        nextPiece = randomPiece();
      }
      const bounds = getPieceBounds(currentPiece);
      currentPosition.x = Math.floor((FIELD.W - bounds.w) / 2);
      currentPosition.z = Math.floor((FIELD.D - bounds.d) / 2);
      currentPosition.y = FIELD.H - bounds.h;
      renderCurrentPiece();
      renderNextPreview();
    }
    spawnPiece();

    // --- Хранилище мешей зафиксированных блоков ---
    const blockMeshes = [];
    for (let x = 0; x < FIELD.W; x++) {
      blockMeshes[x] = [];
      for (let y = 0; y < FIELD.H; y++) {
        blockMeshes[x][y] = [];
        for (let z = 0; z < FIELD.D; z++) blockMeshes[x][y][z] = null;
      }
    }

    // --- Коллизии ---
    function getAbsBlocks(piece, pos) {
      return piece.blocks.map(([dx, dy, dz]) => [pos.x + dx, pos.y + dy, pos.z + dz]);
    }

    function canPlace(piece, pos) {
      return getAbsBlocks(piece, pos).every(([x, y, z]) =>
        x >= 0 && x < FIELD.W &&
        y >= 0 && y < FIELD.H &&
        z >= 0 && z < FIELD.D &&
        fieldGrid[x][y][z] === null
      );
    }

    // --- Движение ---
    function tryMove(dx, dy, dz) {
      const np = { x: currentPosition.x + dx, y: currentPosition.y + dy, z: currentPosition.z + dz };
      if (canPlace(currentPiece, np)) {
        currentPosition = np;
        renderCurrentPiece();
        return true;
      }
      return false;
    }

    // --- Вращение ---
    function rotatePiece(axis, dir) {
      const rotated = currentPiece.blocks.map(([x, y, z]) => {
        if (axis === 'y') return dir > 0 ? [-z, y, x] : [z, y, -x];
        return dir > 0 ? [x, -z, y] : [x, z, -y];
      });
      let mnX = Infinity, mnY = Infinity, mnZ = Infinity;
      rotated.forEach(([x, y, z]) => { mnX = Math.min(mnX, x); mnY = Math.min(mnY, y); mnZ = Math.min(mnZ, z); });
      const norm = rotated.map(([x, y, z]) => [x - mnX, y - mnY, z - mnZ]);
      const test = { blocks: norm, color: currentPiece.color };
      if (canPlace(test, currentPosition)) {
        currentPiece = test;
        renderCurrentPiece();
      }
    }

    // --- Фиксация фигуры ---
    function lockPiece() {
      getAbsBlocks(currentPiece, currentPosition).forEach(([x, y, z]) => {
        fieldGrid[x][y][z] = currentPiece.color;
        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshLambertMaterial({ color: currentPiece.color });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(x + 0.5, y + 0.5, z + 0.5);
        scene.add(cube);
        blockMeshes[x][y][z] = cube;
      });
      if (currentGroup) scene.remove(currentGroup);
      currentGroup = null;
      currentPiece = null;
      checkAndClearLayers();
    }

    // --- Проверка и уничтожение слоёв ---
    function checkAndClearLayers() {
      // Собрать заполненные слои
      const fullLayers = [];
      for (let y = 0; y < FIELD.H; y++) {
        let full = true;
        for (let x = 0; x < FIELD.W && full; x++) {
          for (let z = 0; z < FIELD.D && full; z++) {
            if (fieldGrid[x][y][z] === null) full = false;
          }
        }
        if (full) fullLayers.push(y);
      }

      if (fullLayers.length === 0) {
        spawnPiece();
        return;
      }

      // Подсчёт очков
      const cnt = fullLayers.length;
      const pts = cnt === 1 ? 100 : cnt === 2 ? 300 : cnt === 3 ? 600 : 1000;
      score += pts;
      totalLines += cnt;
      dropInterval = 1000 * Math.pow(0.9, Math.floor(totalLines / 5));
      updateHUD();

      // Запуск анимации уничтожения
      animating = true;
      animStartTime = performance.now();
      animClearedYs = fullLayers;
      animMeshes = [];

      for (const y of fullLayers) {
        for (let x = 0; x < FIELD.W; x++) {
          for (let z = 0; z < FIELD.D; z++) {
            const mesh = blockMeshes[x][y][z];
            if (mesh) {
              mesh.material.color.set(0xffffff);
              animMeshes.push(mesh);
            }
          }
        }
      }
    }

    function finishClearAnimation() {
      // Удалить меши удалённых слоёв
      for (const y of animClearedYs) {
        for (let x = 0; x < FIELD.W; x++) {
          for (let z = 0; z < FIELD.D; z++) {
            const mesh = blockMeshes[x][y][z];
            if (mesh) scene.remove(mesh);
            blockMeshes[x][y][z] = null;
            fieldGrid[x][y][z] = null;
          }
        }
      }

      // Сдвиг слоёв вниз — обработка удалённых слоёв снизу вверх
      const sorted = [...animClearedYs].sort((a, b) => a - b);
      for (const removedY of sorted) {
        for (let y = removedY; y < FIELD.H - 1; y++) {
          for (let x = 0; x < FIELD.W; x++) {
            for (let z = 0; z < FIELD.D; z++) {
              fieldGrid[x][y][z] = fieldGrid[x][y + 1][z];
              fieldGrid[x][y + 1][z] = null;
              blockMeshes[x][y][z] = blockMeshes[x][y + 1][z];
              blockMeshes[x][y + 1][z] = null;
              if (blockMeshes[x][y][z]) {
                blockMeshes[x][y][z].position.y = y + 0.5;
              }
            }
          }
        }
      }

      animMeshes = [];
      animClearedYs = [];
      animating = false;
      spawnPiece();
    }

    // --- Игровой цикл ---
    let dropInterval = 1000;
    let lastDropTime = performance.now();
    let softDrop = false;
    let score = 0;
    let totalLines = 0;
    let animating = false;
    let animStartTime = 0;
    let animMeshes = [];
    let animClearedYs = [];

    function updateHUD() {
      document.getElementById('score-value').textContent = score;
      document.getElementById('lines-value').textContent = totalLines;
    }

    function gameTick(now) {
      if (animating || !currentPiece) return;
      const interval = softDrop ? dropInterval / 4 : dropInterval;
      if (now - lastDropTime >= interval) {
        if (!tryMove(0, -1, 0)) lockPiece();
        lastDropTime = now;
      }
    }

    // --- Управление клавиатурой ---
    window.addEventListener('keydown', (e) => {
      if (animating || !currentPiece) return;
      switch (e.code) {
        case 'ArrowLeft':  tryMove(-1, 0, 0); break;
        case 'ArrowRight': tryMove(1, 0, 0); break;
        case 'ArrowUp':    tryMove(0, 0, -1); break;
        case 'ArrowDown':  tryMove(0, 0, 1); break;
        case 'KeyQ': rotatePiece('y', 1); break;
        case 'KeyE': rotatePiece('y', -1); break;
        case 'KeyR': rotatePiece('x', 1); break;
        case 'KeyF': rotatePiece('x', -1); break;
        case 'Space':
          while (tryMove(0, -1, 0)) {}
          lockPiece();
          break;
        case 'ShiftLeft':
        case 'ShiftRight':
          softDrop = true;
          break;
      }
      if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space'].includes(e.code)) e.preventDefault();
    });

    window.addEventListener('keyup', (e) => {
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') softDrop = false;
    });

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // --- Animation loop ---
    function animate(time) {
      const now = time || performance.now();

      // Анимация уничтожения слоёв
      if (animating) {
        const elapsed = now - animStartTime;
        const t = Math.min(elapsed / 300, 1);
        const s = 1 - t;
        for (const mesh of animMeshes) {
          mesh.scale.set(s, s, s);
        }
        if (t >= 1) {
          finishClearAnimation();
        }
      }

      gameTick(now);
      controls.update();
      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(animate);
  </script>
</body>
</html>
