# Техническое задание: 3D Тетрис («Башня»)

## Общее описание

Браузерная 3D-игра с механикой классического Тетриса, перенесённой в трёхмерное пространство. Игрок укладывает объёмные фигуры на квадратную платформу, формируя башню. Когда горизонтальный слой полностью заполнен — он уничтожается, а всё, что выше, опускается вниз. Игра заканчивается, когда новая фигура не помещается на поле.

*При разработке активно пользуйся Context7 MCP, ищи информацию в интернете.*

## Технологический стек

- **Один HTML-файл** (вся логика, стили и рендеринг внутри)
- **Three.js** (подключается через CDN: `https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js`)
- **Чистый JavaScript** (без фреймворков, без сборщиков)

## Параметры игрового мира

| Параметр | Значение |
|---|---|
| Размер поля (ширина × глубина) | 6 × 6 ячеек |
| Максимальная высота | 12 слоёв |
| Размер одной ячейки | 1 × 1 × 1 условная единица |
| Начальная скорость падения | 1 слой в секунду |
| Ускорение | +10 % каждые 5 уничтоженных слоёв |

---

## ~~Спринт 1: Сцена и игровое поле~~ ✅ DONE

### Цель
Отрисовать пустую 3D-сцену с платформой, камерой и освещением.

### Задачи
1. Создать HTML-файл с подключением Three.js через CDN.
2. Инициализировать сцену, камеру (PerspectiveCamera) и WebGL-рендерер на весь экран.
3. Добавить OrbitControls для вращения камеры мышью вокруг центра поля. Ограничить вращение: не давать камере уходить ниже платформы.
4. Отрисовать платформу 6×6: полупрозрачная сетка на уровне y=0 из тонких линий, чтобы было видно ячейки.
5. Отрисовать полупрозрачные вертикальные границы поля (wireframe-куб 6×6×12) — чтобы игрок видел допустимую область.
6. Добавить освещение: один направленный свет (DirectionalLight) сверху-сбоку и мягкий рассеянный свет (AmbientLight).
7. Добавить адаптацию под размер окна (событие `resize`).

### Результат
Открываем HTML-файл в браузере — видим трёхмерную сетку-платформу, можем вращать камеру мышью. Никакой игровой логики пока нет.

---

## ~~Спринт 2: Фигуры и их появление~~ ✅ DONE

### Цель
Реализовать систему фигур и их появление над полем.

### Задачи
1. Определить внутреннее представление игрового поля — трёхмерный массив `grid[x][y][z]` (6×12×6), где `null` = пусто, иначе — цвет блока.
2. Описать набор фигур. Каждая фигура — массив относительных координат `[dx, dy, dz]` кубиков. Минимальный набор (5 штук):
   - **I-образная** — 4 кубика в линию (1×1×4)
   - **L-образная** — 4 кубика буквой Г (на плоскости)
   - **T-образная** — 4 кубика буквой Т (на плоскости)
   - **S-образная** — 4 кубика зигзагом (на плоскости)
   - **Кубик** — 2×2×1 (4 кубика)
3. Каждой фигуре назначить свой цвет (яркие, контрастные цвета).
4. При старте игры и после фиксации каждой фигуры — выбирать случайную следующую фигуру и размещать её по центру поля на максимальной высоте (y = 11 или ниже, чтобы помещалась).
5. Отрисовать фигуру как группу кубиков (BoxGeometry + MeshLambertMaterial) в сцене Three.js.
6. Показать превью следующей фигуры в углу экрана (отдельная маленькая сцена или HTML-блок).

### Результат
При загрузке на поле появляется случайная цветная фигура. Она пока неподвижна.

---

## ~~Спринт 3: Управление и движение~~ ✅ DONE

### Цель
Реализовать падение фигуры и управление с клавиатуры.

### Задачи
1. Реализовать игровой цикл: каждые N миллисекунд фигура опускается на 1 ячейку вниз (по оси Y).
2. Реализовать проверку коллизий: перед каждым перемещением/вращением проверять, что все кубики фигуры попадают в границы поля (0 ≤ x < 6, 0 ≤ y < 12, 0 ≤ z < 6) и не пересекаются с уже зафиксированными блоками в `grid`.
3. Управление клавишами:
   - **Стрелки ← →** — движение по оси X (влево/вправо)
   - **Стрелки ↑ ↓** — движение по оси Z (ближе/дальше)
   - **Q / E** — вращение фигуры вокруг оси Y (горизонтальный поворот на 90°)
   - **R / F** — вращение фигуры вокруг оси X (вертикальный наклон на 90°)
   - **Пробел** — мгновенный сброс (hard drop) фигуры до упора вниз
   - **Shift** — ускоренное падение (soft drop), пока зажат
4. При вращении: если фигура после поворота выходит за границы или пересекается с блоками — отменить поворот (не поворачивать).
5. Когда фигура не может опуститься ниже — зафиксировать её: записать все кубики в `grid`, убрать Three.js-объект фигуры, создать отдельные кубики для каждой ячейки.

### Результат
Фигура падает, ей можно управлять стрелками, вращать, сбрасывать вниз. После приземления она фиксируется, появляется новая.

---

## ~~Спринт 4: Уничтожение слоёв и очки~~ ✅ DONE

### Цель
Реализовать основную механику: уничтожение заполненных слоёв и подсчёт очков.

### Задачи
1. После фиксации каждой фигуры — проверить все слои (y = 0 .. 11): если слой полностью заполнен (все 36 ячеек заняты) — пометить его на уничтожение.
2. Уничтожение слоя:
   - Удалить все Three.js-объекты (кубики) этого слоя из сцены.
   - Очистить соответствующий слой в `grid`.
   - Все слои выше — сдвинуть вниз на 1 (и в массиве, и визуально — переместить Three.js-объекты).
3. Если уничтожено несколько слоёв одновременно — обработать все, начиная снизу.
4. Добавить простую анимацию уничтожения: например, кубики слоя на 300 мс становятся белыми и уменьшаются, после чего исчезают.
5. Подсчёт очков:
   - 1 слой = 100 очков
   - 2 слоя за раз = 300 очков
   - 3 слоя за раз = 600 очков
   - 4+ слоя за раз = 1000 очков
6. Отображать текущий счёт и количество уничтоженных слоёв в HTML-оверлее поверх canvas.
7. Увеличивать скорость падения по формуле: каждые 5 уничтоженных слоёв интервал падения уменьшается на 10 %.

### Результат
Полностью играбельная механика: слои уничтожаются, очки копятся, скорость растёт.

---

## ~~Спринт 5: Конец игры и UI~~ ✅ DONE

### Цель
Добавить условие проигрыша, экраны старта/окончания, паузу.

### Задачи
1. Проверка проигрыша: если новая фигура при появлении пересекается с уже зафиксированными блоками — игра окончена.
2. Экран «Game Over»: HTML-оверлей с финальным счётом и кнопкой «Играть снова».
3. Стартовый экран: название игры, краткая инструкция по управлению, кнопка «Старт».
4. Пауза по клавише **Escape**: остановить игровой цикл, показать оверлей «Пауза» с кнопкой «Продолжить».
5. Показать подсказку по управлению: небольшой блок в углу экрана с перечнем клавиш (можно скрывать/показывать).
6. Добавить визуальную «тень» (ghost piece): полупрозрачная проекция текущей фигуры на позицию, куда она упадёт. Это помогает игроку целиться.

### Результат
Полноценный игровой цикл: старт → игра → проигрыш → повтор. Есть пауза, подсказки, ghost piece.

---

## Спринт 6: Полировка и эффекты

### Цель
Довести визуал и ощущения до приятного уровня.

### Задачи
1. Добавить лёгкие тени от блоков (включить `renderer.shadowMap`, настроить `castShadow` / `receiveShadow`).
2. Плавное падение: вместо телепортации на 1 ячейку — плавная интерполяция позиции (lerp) между тиками.
3. Эффект при мгновенном сбросе: кратковременная вспышка или «след» от падения.
4. Звуковые эффекты (Web Audio API или простые `<audio>` теги): звук приземления, звук уничтожения слоя, звук проигрыша. Можно генерировать программно через `OscillatorNode`.
5. Адаптация под мобильные устройства: добавить экранные кнопки управления (полупрозрачные) для touch-экранов. Минимум: кнопки направлений, вращения и сброса.
6. Сохранение рекорда в `localStorage`.

### Результат
Игра выглядит и ощущается завершённой: плавные анимации, звук, тени, поддержка мобильных.

---

## Рекомендации для AI-агента

- **Каждый спринт** должен завершаться **рабочим HTML-файлом**, который можно открыть в браузере и проверить.
- Не используй внешние зависимости, кроме Three.js через CDN.
- Весь код — **в одном файле**. JavaScript и CSS — внутри HTML (`<script>`, `<style>`).
- Пиши **чистый, комментированный код**. Каждая функция — с кратким комментарием.
- После каждого спринта проверяй, что предыдущая функциональность не сломалась.
- Код должен работать в последних версиях Chrome, Firefox, Safari.